@page
@model VinderenApi.Pages.Authentication.TechnicalOverviewOfJWTusageModel
@{
	<h3>Technical Overview of the JWT Usage</h3>
	<pre>
    Secret Key: The secret key (referred to as Secret2 in your code) is a shared secret between your server and any clients or services 
    that need to work with JWT tokens. This secret key is used to both create (sign) and verify (validate) JWT tokens.

    Signature: The signature is a cryptographic value generated by hashing the encoded header and payload along with the secret key. 
    This signature is unique to each token and is used for verification on the server-side. It ensures that the token hasn't been 
    tampered with and was indeed generated by a trusted source. 
    The signature is not part of the token's JSON representation; it's a separate component used for validation.

    Header and Payload: These are the visible parts of the JWT token when it's encoded. 
    They are Base64Url-encoded JSON objects containing information about the token itself (header) and the claims (payload). 
    The header typically specifies the signing algorithm (e.g., "alg": "HS256"), 
    while the payload contains claims like user information, expiration time, etc.

    Here's a simplified overview of how a JWT is created:

    The header and payload are converted to JSON and Base64Url-encoded.
    The encoded header and payload are concatenated with a period ('.') separator.
    The concatenated string is then hashed with the secret key using the specified algorithm (e.g., HS256) to generate the signature.
    Finally, the header, payload, and signature are concatenated using periods to create the complete JWT token.
    When a client sends this token to your server, your server can validate it by recreating the signature using the same secret key 
    and comparing it to the signature in the token. If they match, the token is considered valid.

    So, Secret2 value is the secret key used for creating and verifying JWT tokens, 
    and the signature is generated using this secret key along with the encoded header and payload.
    <h4>NB!!</h4>
    So, signing is not the same as encryption. It provides a way to ensure the data has not been altered in transit and can be trusted, 
    but it doesn't hide the actual content of the token. Encryption, on the other hand, makes the content unreadable without the 
    appropriate decryption key. See <a href="CryptoTermDifferences">Crypto Term Differences</a>


    Let's create a JWT token in a .NET Core 6 application (ASP.NET Core 6) and send it from the server to a React frontend. 
    Here's a step-by-step example:

    <h4>Server-Side (ASP.NET Core 6):</h4>

    Create an ASP.NET Core 6 Web API using Visual Studio or your preferred development environment.

    Install the System.IdentityModel.Tokens.Jwt NuGet package. This package provides JWT-related functionalities.

    Create a Controller (e.g., AuthController) with methods to handle user registration and login.

    Here's a simplified example of an AuthController:

    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Extensions.Configuration;
    using Microsoft.IdentityModel.Tokens;
    using System;
    using System.IdentityModel.Tokens.Jwt;
    using System.Security.Claims;
    using System.Text;

    namespace YourNamespace.Controllers
    {
        [Route("api/auth")]
        [ApiController]
        public class AuthController : ControllerBase
        {
            private readonly IConfiguration _configuration;

            public AuthController(IConfiguration configuration)
            {
                _configuration = configuration;
            }

            [HttpPost("login")]
            public IActionResult Login()
            {
                // Replace this with actual authentication logic.
                var user = new { Id = "user123", Email = "user@example.com" };

                &#105;f (user == null)
                {
                    return Unauthorized();
                }

                var secretKey = _configuration["JwtConfig:Secret"];
                var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey));

                var claims = new[]
                {
                    new Claim(JwtRegisteredClaimNames.Sub, user.Id),
                    new Claim(JwtRegisteredClaimNames.Email, user.Email),
                    new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
                    new Claim(JwtRegisteredClaimNames.Iat, DateTime.Now.ToUniversalTime().ToString(), ClaimValueTypes.Integer64)
                };

                var token = new JwtSecurityToken(
                    issuer: _configuration["JwtConfig:Issuer"],
                    audience: _configuration["JwtConfig:Audience"],
                    claims: claims,
                    expires: DateTime.UtcNow.AddHours(1),
                    signingCredentials: new SigningCredentials(key, SecurityAlgorithms.HmacSha256)
                );

                var tokenString = new JwtSecurityTokenHandler().WriteToken(token);

                return Ok(new { Token = tokenString });
            }
        }
    }

    Configure JWT in appsettings.json:

    {
      "JwtConfig": {
        "Secret": "your_secret_key_here",
        "Issuer": "your_issuer",
        "Audience": "your_audience"
      },
      // Other configurations...
    }
  
    Configure JWT Authentication in Startup.cs:

    using Microsoft.AspNetCore.Authentication.JwtBearer;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.IdentityModel.Tokens;
    using System.Text;

    public void ConfigureServices(IServiceCollection services)
    {
        // Other configurations...

        var jwtConfig = Configuration.GetSection("JwtConfig").Get&lt;JwtConfig&gt;();
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtConfig.Secret));

        services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
        })
        .AddJwtBearer(jwt =>
        {
            jwt.SaveToken = true;
            jwt.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = key,
                ValidateIssuer = true,
                ValidIssuer = jwtConfig.Issuer,
                ValidateAudience = true,
                ValidAudience = jwtConfig.Audience,
                RequireExpirationTime = true,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };
        });

        // Other configurations...
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        // Other configurations...

        app.UseAuthentication();

        // Other configurations...
    }

    <h4>Client-Side (React):</h4>

    Create a React application using Create React App or your preferred setup.

    Make an HTTP POST request to the server when a user logs in. You can use a library like axios or the fetch API. 
    Here's a simplified example:

    import axios from 'axios';

    const login = async (email, password) => {
        try {
            &#99;onst response = await axios.post('/api/auth/login', {
                email,
                password,
            });

            &#99;onst { token } = response.data;

            / Store the token in your application state or local storage.
            / You can use it for subsequent authenticated requests.

            &#114;eturn token;
        } catch (error) {
            console.&#101;rror('Login failed:', error);
            &#116;hrow error;
        }
    };

    // Example usage:
    // const token = await login('user@example.com', 'password123');
    
    Store the JWT token: Once you receive the JWT token from the server, store it in your application's state or local 
    storage for future authenticated requests.
    Remember to handle user registration and authentication securely and replace the placeholder values with your actual 
    configurations and authentication logic. This example focuses on the JWT token generation and usage within the ASP.NET Core 6 
    backend and a React frontend.

    <h4>Composition of a JWT</h4>
    A JWT (JSON Web Token) is composed of three parts separated by periods (.): Header, Payload, and Signature. 
    These three parts are Base64Url-encoded JSON strings. Let's break down each part:

    1. Header: Contains metadata about the token, such as the type of token ("typ": "JWT") and the signing algorithm ("alg"), 
    which is used to sign the token. It's typically Base64Url-encoded JSON. In your ASP.NET Core example, you're using the HS256 algorithm, 
    which means HMAC-SHA256.

    2. Payload: Contains claims, which are statements about an entity (typically, the user) and additional data. 
    Claims are categorized into registered, public, and private claims. Registered claims are predefined claims such as "sub" (subject), "iss" (issuer), "aud" (audience), "exp" (expiration time), and "iat" (issued at). You can also add custom claims. It's also typically Base64Url-encoded JSON.

    3. Signature: To create the signature part you have to take the encoded header, the encoded payload, a secret, 
    the algorithm specified in the header, and sign that.

    Here's an example of what a JWT token might look like:

    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
    .eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9
    .SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

        Header: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9

    Base64Url-encoded JSON: {"alg": "HS256", "typ": "JWT"}
    Payload: eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9

    Base64Url-encoded JSON: {"sub": "1234567890", "name": "John Doe", "iat": 1516239022, "exp": 1516239022}
    Signature: SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

    This part is created by hashing the encoded header and encoded payload using the HMAC-SHA256 algorithm, 
    with your secret key as the key. This signature is used to verify the integrity of the token and ensure that 
    it hasn't been tampered with.
    In your ASP.NET Core 6 backend, you generate this JWT token using the JwtSecurityTokenHandler, 
    and the WriteToken method encodes the header and payload, and computes the signature for you. 
    When you send this token to the client, it's the full token, including all three parts.

	</pre>
}
